## Структури от данни
Структурите от данни са начинът, по който тези данни са организирани, така че операциите върху тези данни да са лесни, бързи и ефикасни. Досега сте запознати с поне два вида структури от данни - `list` и `dictionary`. В `list` данните са подредени последователно и се достъпват чрез съотетния индекс. В `dictionary` данните се достъпват чрез ключ. Всеки запис може да си го представите като Key-Value двойка. Достъпвате определена стойност чрез нейния ключ. 

Тук ще се разгледа и имплементира друг вид стуктура от данни - свързан списък.

## Свързан списък (Linked list)
Преди да ви въведа в свързания списък ще направя бързо припомняне за обикновения `list` в Python. 
```python
l = [1, 2, 3, 4]
print(l[0])
print(l[1])
print(l[3])

Output: 
1
2
4
```
Нищо сложно не се случва тук. Това е пример как сме запазили последователно 4 цифри и как ги достъпваме.

### Свързан списък (this time for real)
В един свързан списък данните се съхраняват във т. нар. възли (nodes). Всеки възел държи стойност и обект към възела, който е след него.

<img src="./resources/first_node.png">

Тази готина картинка изобразява един възел. Вътре в себе си държи стойност (в случая тя е 1 - първата стойност от list-а по-горе) и следващия обект в списъка. В момента нямаме втори възел, затова `next` сочи към `None`.

Да добавим още една цифра.

<img src="./resources/two_nodes.png">

Първият елемент е със стойност `1`. След като вече имаме и втори елемент, `next` на първия обектът сочи към втория `Node` със стойност `2`. Трети елемент нямаме, затова на втория възел `next` сочи към `None`. Мисля че схващате идеята. Познайте как ще изглежда картинката, ако добавим трети и четвърти възел.

<img src="./resources/all_nodes.jpg">

### Имплементация
Как ще имплементираме това нещо в Python? Всеки възел може да бъде описан с клас. Всеки клас ще държи два обекта - стойност и `next`. 
```python
class Node:
	  def __init__(self, value):
		self.value = value
		self.next = None
```
Всеки път, когато трябва да създадем възел, ще създаваме обект от клас Node. Всеки нов възел първоначално няма следващ такъв, но трябва все пак да има в себе си обект `next`. Затова създаваме и инициализираме `self.next = None`. 

Да създадем списъка на картинката:
```python
class Node:
	  def __init__(self, value):
		self.value = value
		self.next = None

n1 = Node(1)
n2 = Node(2)
n3 = Node(3)
n4 = Node(4)
```

В момента има създадени възли, но все още нямат връзка помежду си. Правим и нея.

```python
n1.next = n2
n2.next = n3
n3.next = n4
```

Готово. Да го пробваме! Дефинираме функция, която ще приема първия възел от един свързан списък. Имайки него, тя трябва да изкара на екрана всички стойности от списъка.

```python
def print_list(first_node):
	current_node = first_node
	while current_node != None:
		print(current_node.value)
		current_node = current_node.next
```

Какво прави функцията?
1. `current_node = first_node` - Минаваме през всеки един възел от списъка. Всеки един възел достъпваме, чрез името `current_node`. Започваме от първия възел, затова казваме, че `current_node` ще сочи към същия обект, към който сочи и `first_node`. 
1. `current_node = current_node.next` - След като сме приключили със сегашния възел, преминаваме на следващия. Всеки възел държи връзка към следващия. Съответно казваме, че `current_node` ще сочи към `current_node.next`. Така с `current_node` вече достъпваме следващия елемент.
1. `while current_node != None:` - Последният възел няма следващ, затова неговият `next` сочи към None. След като на всяка итерация `current_node` сочи към следващия възел, той в един момент ще стигне последния. Когато приключи и с последния, `current_node = current_node.next` ще се изпълни, където `current_node.next` сочи към None, следователно `current_node` ще сочи към None и цикълът ще приключи.

<img src="./resources/iterate_nodes.png">

___
При имплементация на свързан списък пазим само първия възел. Конвенцията е да го достъпваме, чрез име `head`. Да дефинираме функция, която добавя нов възел в края на списъка. Нека функцията приема `head` и само стойността, която ще се държи, а самия `Node` да го създава тя.

```python
def add(head, value):
	new_node = Node(value)
	current_node = head
	
	while current_node.next != None:
		current_node = current_node.next
	
	current_node.next = new_node
```

Какво прави функцията?
1. `def add(head, value)` - Приема само първия възел от списъка и стойността, която ще се държи във възел, който ще закачим накрая.
1. `new_node = Node(value)` - След като функцията приема стойността на новия възел, а не самия възел, тогава създаваме новия възел ние. По-късно ще разберете, защо го правим по този начин.
1. `current_node = head` - Трябва да минем през всички възли в списъка (както направихме във функцията `print_list`). Разбира се ще започнем от първия.
1. Цикъла
	```python
	while current_node.next != None:
			current_node = current_node.next
	```
	За разлика от функцията `print_list`, тук не итерираме докато `current_node` не сочи към `None`, а докато `current_node.next` не сочи към `None`. Схващате ли разликата? Искаме да стигнем до последния възел, а не до един след него. Последният възел е този, чийто `next` сочи към `None` (вижте картинките). В момента, в който `current_node.next` сочи към `None`, значи `current_node` е последния възел.
1. `current_node.next = new_node` - След като цикълът приключи, `current_node` ще сочи към текущия последен възел. Към него закачаме новия възел.

Да пробваме как работи.
```python
class Node:
	def __init__(self, value):
		self.value = value
		self.next = None

def print_list(head):
	current_node = head
	while current_node != None:
		print(current_node.value)
		current_node = current_node.next

def add(head, value):
	new_node = Node(value)
	current_node = head
	
	while current_node.next != None:
		current_node = current_node.next
	
	current_node.next = new_node

head = Node(1)

add(head, 5)
add(head, 'Multicet')

print_list(head)

Output:
1
5
Multicet
```
