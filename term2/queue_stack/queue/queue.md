# Опашка (Queue)
Преди да сте чели този урок е добре да сте минали този за [свързани списъци](https://github.com/bkolarov/elsys_python_course_9a_2016/blob/master/term2/linked_list/linked_list.md).

Опашката е вид структура от данни. Заедно с опашка, трябва да запомните думата FIFO - First In First Out. Това е принципът, по който данните се вкарват в структурата и се изкарват от нея. 

Представете си опашка на каса. Който първи стигне, той първи ще свърши работа и ще си тръгне. Всеки нов клиент се нарежда най-отзад на опашката. По същия начин се записват и изкарват данните от една такава структура от данни. 

<img src="./resources/queue.png">

Операциите по тази структура са:
* enqueue - добавяме нов запис най-отзад в опашката
* dequeue - изкарваме записа, кой се намира най-отпред в опашката

<img src="./resources/enqueue_dequeue.png">

Триене посредата на опашката нямаме. Приемаме, че трябва да минем през цялата информация, която е записана в структурата. Ако някой е решил да се реди за безплатни кебабчета, няма да си тръгне, пък каквото ще да става.

## Имплементация
Опашка може да се имплементира по повече от един начин. Може да е чрез обикновен масив, може и чрез свързан списък. 

### Чрез масив
При имплементация чрез масив държим всички елементи в един масив (очевидно) или в случая в Python ги държим в `list`. Първият, който е записан в опашката, ще е първият елемент от масива. Вторият ще е втория елемент и тн. Проблемът е, когато вадим от опашката. Винаги вадим първия (този най-отпред). Това значи, че след като извадим най-първия елемент, трябва да преместим всички останали с едно, така че вторият да стане първи, третият да стане втори и тн.

<img src="./resources/queue_array.png">

Това ще се случва всеки път при вадене от опашката.

### Чрез свързан списък
Това е начинът, който ние ще имплементираме. При този подход записите, също като в свързания списък, ще се държат във визли (nodes). Всеки възел ще държи съответната стойност. Разликата идва там, че при свързания списък всеки възел държи връзка към следващия. Тук всеки възел държи връзка към предишния. Ценко е първи на опашката. Зад него идва Марто. Зад Марто идва Никола. Ценко знае, че Марто е зад него, а Марто знае, че Никола е зад него. Никола пък знае, че няма никого зад него (None).

<img src="./resources/linked_queue.png">

При работата с тази структура ще празим две връзки. Връзка към първия възел, която ще наричаме `head` и връзка към последния, която ще наричаме `tail`. Всеки път като добавяме елемент, ще го закачаме като предишен елемент на `tail`. Всеки път като вадим елемент, ще преместваме `head` да сочи към неговия предишен.

На изображението по-долу е показана една и съща опашка. В горната опашка махаме един възел и добавяме нов. Долната опашка е резултата.
<img src="./resources/queue_operations.png">
