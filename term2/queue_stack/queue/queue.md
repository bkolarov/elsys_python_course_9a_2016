# Опашка (Queue)
Преди да сте чели този урок е добре да сте минали този за [свързани списъци](https://github.com/bkolarov/elsys_python_course_9a_2016/blob/master/term2/linked_list/linked_list.md).

Опашката е вид структура от данни. Заедно с опашка, трябва да запомните думата FIFO - First In First Out. Това е принципът, по който данните се вкарват в структурата и се изкарват от нея. 

Представете си опашка на каса. Който първи стигне, той първи ще свърши работа и ще си тръгне. Всеки нов клиент се нарежда най-отзад на опашката. По същия начин се записват и изкарват данните от една такава структура от данни. 

<img src="./resources/queue.png">

Операциите по тази структура са:
* enqueue - добавяме нов запис най-отзад в опашката
* dequeue - изкарваме записа, кой се намира най-отпред в опашката

<img src="./resources/enqueue_dequeue.png">

Триене посредата на опашката нямаме. Приемаме, че трябва да минем през цялата информация, която е записана в структурата. Ако някой е решил да се реди за безплатни кебабчета, няма да си тръгне, пък каквото ще да става.

## Имплементация
Опашка може да се имплементира по повече от един начин. Може да е чрез обикновен масив, може и чрез свързан списък. 

### Чрез масив
При имплементация чрез масив държим всички елементи в един масив (очевидно) или в случая в Python ги държим в `list`. Първият, който е записан в опашката, ще е първият елемент от масива. Вторият ще е втория елемент и тн. Проблемът е, когато вадим от опашката. Винаги вадим първия (този най-отпред). Това значи, че след като извадим най-първия елемент, трябва да преместим всички останали с едно, така че вторият да стане първи, третият да стане втори и тн.

<img src="./resources/queue_array.png">

Това ще се случва всеки път при вадене от опашката.

### Чрез свързан списък
Това е начинът, който ние ще имплементираме. При този подход записите, също като в свързания списък, ще се държат във визли (nodes). Всеки възел ще държи съответната стойност. Разликата идва там, че при свързания списък всеки възел държи връзка към следващия. Тук всеки възел държи връзка към предишния. Ценко е първи на опашката. Зад него идва Марто. Зад Марто идва Никола. Ценко знае, че Марто е зад него, а Марто знае, че Никола е зад него. Никола пък знае, че няма никого зад него (None).

<img src="./resources/linked_queue.png">

При работата с тази структура ще празим две връзки. Връзка към първия възел, която ще наричаме `head` и връзка към последния, която ще наричаме `tail`. Всеки път като добавяме елемент, ще го закачаме като предишен елемент на `tail`. Всеки път като вадим елемент, ще преместваме `head` да сочи към неговия предишен.

На изображението по-долу е показана една и съща опашка. В горната опашка махаме един възел и добавяме нов. Долната опашка е резултата.
<img src="./resources/queue_operations.png">

### Клас Queue
Също като при свързания списък, ще имаме един клас, който ще се грижи за добавянето и махането на елементи. Ще имаме и втори вътрешен клас Node, който да представлява възела.

```python
class Queue:
	def __init__(self):
        # The queue is empty but it must have its attributes head and tail. Create them and initialize them with None.
        # Also create the size attribute and initialize it with 0 (again, the queue is empty).
		self.head = self.tail = None
        self.size = 0
		
	class Node:
		def __init__(self, value):
			self.value = value
			self.prev = None
```

### enqueue
Функцията за добавяне ще приема стойността, която искаме да държим в опашката. Тя ще създава възела и ще го добавя като предишен на сегашния `tail`. Имаме два случая, които могат да възникнат:
- Опашката може да е празна - тогава и `head` и `tail` ще бъдат `None`. В този случай и на двата ще кажем да сочат към новия възел.
- Опашката не е празна - тогава просто добавяме новия възел като предишен на `tail`. После преместваме `tail` да сочи към новия възел, тъй като той ще е новият последен такъв. Когато се наредите на опашка в лавката, вие ставате последния чакащ.

```python
def enqueue(self, value):
		new_node = Queue.Node(value)
		
		if self.is_empty():
			self.head = self.tail = new_node
		else:
			self.tail.prev = new_node
			self.tail = new_node
			
		self.size += 1
		
	def is_empty(self):
		return self.head == None and self.tail == None
```
```
q = Queue()

q.enqueue(1)
q.enqueue(2)
q.enqueue(3)

current = q.head
while current != None:
	print(current.value)
	current = current.prev
```
```
Output:
1
2
3
```
Какво прави функцията?
- Функцията приема стойност. Създаваме възел, в който да я държим:
    ```python
    def enqueue(self, value):
		new_node = Queue.Node(value)
    ```
- Обработка на случая, ако опашката е празна:
    ```python
    if self.is_empty():
			self.head = self.tail = new_node
    ...
    ```
    Дефинирали сме си функция, която проверява дали опашката е празна и връща съответно `True` или `False`. Опашката е празна, когато и `head` и `tail` сочат към `None`. 
    В случай, че опашката е празна, когато добавим нов възел, той е и пръв и последен. Следователно и `head` и `tail` трябва да сочат към новия възел.
- Добавяне, когато в опашката има възли:
    ```python
    ...
    else:
			self.tail.prev = new_node
			self.tail = new_node
    ```
    Ако в опашката вече има възли, то `tail` сочи към текущия последен такъв. Когато добавяме нов, казваме на последния кой му е преидшен: `self.tail.prev = new_node`. След което преместваме `tail` да сочи към новия последен: `self.tail = new_node`. 
- Увеличаваме размера с единица.
